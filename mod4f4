#!/usr/bin/env bash
# mod4f4 v0.06
# GPL v3



# https://app.swaggerhub.com/apis-docs/NexusMods/nexus-mods_public_api_params_in_form_data/1.0#/

[ -n "$DEBUG" ] && set -x

usage="Usage: $0 --init | $0 --gitk | $0 [options..] <archive.7z|archive.rar|archive.zip> [rsync options..]

Options:
    --init      set up links and git revision control (no other arguments required).

    --gitk      module management using gitk.

    --subset=RE includes only the matching module (sub)directories.
    --dest-base=path  directory wherein to place files. Default is 'Data/' unless --subset is provided
                      and the transferred folders match ones in the root. RE: extended regular expression.

                Whether or not a directories trailing slash is included in the capture matters.
                If uncaptured the directory is copied, otherwise the directory contents as rsync behaves.

    --rm        remove the extracted module directory after commit.
    --no-stage  don't stage and commit (allows manual staging). This implies --keep-mod.
                Note that together with the --dry-run rsync option, no package contents are transferred.
                The filename and directoryname case-insensitivity resolution is still run, though.

    If there's Nexus information available (which may require manual html download for adult mods),
    requirements for the mod will be checked, using commit messages.

    --message=<string> commit with this specified message. This also implies skipping the nexus number query.
    --ignore-nexus-reqs=RE     ignore a module's listed, but missing nexus requirements
    --ignore-off-site-reqs=RE  ignore a module's listed, but potentially missing off-site requirements

for rsync options, see \`man rsync' or \`rsync --help'
"
mod_root="$PWD"

sha512out="9197a9a0bc6fc760387b7d119f8464545bc97d44fbc2696c22bdd6125973a9b5d90"\
"cf803e7356752cb4b942e75afe680dd08bb9734bf549065abb529ce4735be  -"
DLC="Coast NukaWorld Robot UltraHighResolution workshop"

game_version=1.10.163.0.0

warn() {
  echo -e "$1\n" 1>&2;
}

die() {
  warn "from `pwd`:\n${1:-$usage}";
  cd "$mod_root"
  exit ${2:-1}
}
stash=
console_requirements=
for cmd in git rsync sed sort uniq wc xml2 yad xmllint wget; do
  which $cmd &> /dev/null
  (( $? == 0 )) || console_requirements="${console_requirements+\n}$cmd not found."
done
[ -n "$console_requirements" ] && die "${console_requirements}\ninstall aforementioned on your system first."

# set up links to Fallout 4 if not already present
if [ "$1" = "--init" ] || [ "$1" = "--init-no-check" ]; then
  if [ ! -e "$mod_root/f4" ]; then
    STEAM_LIBRARY="${STEAM_LIBRARY:-${HOME}/.steam/steam}"
    [ ! -d "$STEAM_LIBRARY" ] && die "Steam library is not linked, nor found. "\
"Run with\nSTEAM_LIBRARY='PATH' $0\nwhere PATH is what is listed in your "\
"Steam->Settings->Downloads->STEAM LIBRARY FOLDERS (the one with default=yes)"
    f4="${STEAM_LIBRARY}/SteamApps/common/Fallout 4"
    [ -d "$f4" ] || die "You don't seem to have Fallout 4 installed in '$f4'"
    ln -s "$f4" f4
  fi

  if [ ! -d "$mod_root/f4/.git" ]; then
    cd f4/
    if ["$1" = "--init" ]; then
      for dlc in ${DLC}; do 
        [ -z "$(ls -1 "f4.$dlc"*)" ] && die "You seem to be missing downloadable content $dlc "\
"(ignored with --init-no-check)"
      done
      if [ "$(find * | egrep -v '^(\.git|Data/DLC)' | sha512sum)" != "$sha512out" ]; then
        die "Your Fallout 4 directory seems to already have modules applied (ignored with --init-no-check)"
      fi
    fi
    git init
    warn "Setting up revision control.. (takes a few minutes)" 1>&2
    git ls-files -o --exclude-standard | xargs -r -d "\n" -I {} git add "{}"
    git commit -m 'Clean Fallout 4 game'
    cd - 2>/dev/null
  fi
  exit 0
elif [ ! -e "$mod_root/f4" ]; then
  die "run $0 --init to set up links and revision control (takes several minutes)."
elif [ "$1" = "--gitk" ]; then
  which gitk &> /dev/null
  (( $? == 0 )) || die "gitk not found.\ninstall this on your system first or use commandline git commands instead."
  cd f4/;
  gitk&
  cd - 2>/dev/null
  exit 0
fi

# resolve file or directory name windows case-insensitivity duplicates by preserving the earliest tracked name
# argument d or f: -type to find
resolve_tracked_case_insensitivity_for_type() {
  dups="$(find -H * -mount -type $1 | sort --ignore-case | uniq -i -D)"
  [ -z "$dups" ] && return 0 # done
  first=;
  while read snd; do
    if [ -n "$first" ] && [ "${snd,,}" = "${first,,}" ]; then
      fst_in_repo="$(git ls-files "$first/")"
      snd_in_repo="$(git ls-files "$snd/")"
      if [ -n "$snd_in_repo" ]; then
        [ -n "$fst_in_repo" ] && die "both $first and $snd are tracked" 126
        if [ -d "$snd" ]; then
          [ -n "$(ls -1 $first/)" ] && mv "$first"/* "$snd/" || rmdir "$first"
        elif [ -f "$first" ]; then
          mv "$first" "$snd";
        fi
        first="$snd"
      else
        [ -z "$fst_in_repo" ] && echo "neither $first nor $snd tracked, just using first" 1>&2
        if [ -d "$snd" ]; then
          [ -n "$(ls -1 $snd/)" ] &&  mv "$snd"/* "$first/" || rmdir "$snd"
        elif [ -f "$snd" ]; then
          mv "$snd" "$first"
        fi
      fi
      [ -d "$snd/" ] && rmdir --ignore-fail-on-non-empty "$snd/"
    else
      first="$snd"
    fi
  done < <(echo "$dups")
  return 1 # ok, repeat.
}

# whether or not you capture the trailing directory slash with --subset regexp matterd.
# if uncaptured the directory is copied, otherwise the directory contents.

keep_mod=1
stage=1
append_message=
dest_base=Data/
ignore_nexus_reqs=
ignore_off_site_reqs=
re="[^ ][^/]*"
while (( $# != 0 )) ;do
  case "$1" in
    --subset=*) re="${1:9}";;
    --subset) shift; re="$1";;
    --rm) keep_mod=0;;
    --no-stage) stage=0;;
    --dest-base=*) dest_base="${1:12}";;
    --dest-base) shift; dest_base="$1";;
    --ignore-nexus-reqs=*) ignore_nexus_reqs="${1:20}";;
    --ignore-nexus-reqs) shift; ignore_nexus_reqs="$1";;
    --ignore-off-site-reqs=*) ignore_off_site_reqs="${1:24}";;
    --ignore-off-site-reqs) shift; ignore_off_site_reqs="$1";;
    --message=*) append_message="${1:10}";;
    --message) shift; append_message="$1";;
    --*) die "$usage\nError: unrecognized option $1 (rsync options come after the mod archive)";;
    *) break;;
  esac
  shift;
done

ar="$1"
shift
[ -e "$ar" ] || die "${usage}\nError: No archive: '$ar'"

case "${ar##*.}" in
  7z)  uz="7z ";;
  zip) uz="unzip -";;
  rar) uz="unrar ";;
  *) echo "unrecognized extension for $ar, is it an archive?" 1>&2;
     exit 1;;
esac
# all list files between these markers

ar_files="$(${uz}l "$ar" | sed -n -r '/^---/,/^---/{/^---/b;s~^.*  ([^ ].*)$~\1~p}')"
ar_dirs="$(echo "$ar_files" | sed -n -r "s~^($re)(.*)?$~\1~p" | uniq)"

[ -z "$ar_dirs" ] && die "regular expression '$re' matches no files in archive '$ar'"


bn="$(basename "${ar%.*}")"

stash="${re%%/*}"

if [ -z "$(echo "$ar_dirs" | egrep -v "^$stash/" 2>&1)" ] &&
    [ -z "$(find -H f4/ -mount -type d -iname "$stash")" ]; then
  warn "package contained installer directory '$stash'/\nonly extracting seleced with '${re}'"
 
  [ -d "$stash" ] && keep_mod=1 || ${uz}x "$ar" "$stash" || die "..that was \`${uz}x $ar \"$stash\"' that failed." 2

  find -H f4/ -mount -maxdepth 1 | grep -i -q -w -f <(ls -1 "$stash")
  (( $? == 0 )) && dest_base=""

elif (( $(echo "$ar_dirs" | wc -l) != 1 )) || [ -z "$(echo "$ar_dirs" | grep -vi "^fomod$")" ] ||
    [ -n "$(find -H f4/ -mount -type d -iname "$ar_dirs")" ]; then

  warn "Package contained no dedicated installer directory, using '$bn'"

  stash="$bn"
  if [ -d "$stash" ]; then
    cd "$stash"
    keep_mod=1
  else
    mkdir "$stash" || die "mkdir '$stash'?"
    cd "$stash"
    ${uz}x "$mod_root/$ar" || die "..that was \`${uz}x $mod_root/$ar' that failed." 2
  fi
else
  stash="$ar_dirs"
  warn "package contained installer directory $stash/"

  [ -d "$stash" ] && keep_mod=1 || ${uz}x "$ar" || die "..that was \`${uz}x $ar' that failed." 2
fi

readme=()
fomod_dir=
fomod_info=
fomod_config=
while read f; do
  [ -e "$f" ] || die "$ar: $f does not exist?"
  [ -n "$(echo "$f" |egrep -i "^([^/]+/)?fomod$")" ] && fomod_dir="$f"
  [ -n "$(echo "$f" |egrep -i "^([^/]+/)?fomod/info.xml$")" ] && fomod_info="$f"
  [ -n "$(echo "$f" |egrep -i "^([^/]+/)?fomod/ModuleConfig.xml$")" ] && fomod_config="$f"
  [ -n "$(echo "$f" |egrep -i "^([^/]+/)?[^/]*readme\.txt$")" ] && readme[${#readme[@]}]="$f"
done < <(echo "$ar_files")

# TODO: adult mods may require an apikey. Registration needs to be done
# https://help.nexusmods.com/article/114-api-acceptable-use-policy
# Application-Version (e.g. "0.05") Please ensure this reflects the current release.
# Application-Name (eg. "mod4f4")


# below is for parsing the fomod moduleConfig.xml

sources=()
dests=()
mod_reqs=
commit_message=

if [ -f "$fomod_info" ]; then

  commit_message="$(xml2 < "$fomod_info"| sed -n -r 's~^/fomod/([^=]+)=~\1: ~;/Description: /!p')"
  mod_url="$(echo "$commit_message" | sed -n 's/^Website: //p')"

elif [ -z "$append_message" ]; then
  mod_nr="$(basename "${ar%.*}" | tr -c -s "[0-9.]" "\n" | egrep "^[0-9]{1,5}$")"
  if (( $(echo "$mod_nr" | wc -l) != 1 )); then
    mod_nr="$(echo "$mod_nr" | sort -rg | sed '1{s/^/TRUE /;b};s/^/FALSE /' | xargs \
        yad --title="Select module number.." --list --width=640 --height=480\
        --text="<span foreground='white' font='18'>Please indicate the mod nr. Cancel if none.</span>" \
        --list --radiolist --column=selection:RD --column=number:NUM)"
    n=$(echo "${mod_nr}" |tr -c -d "[:digit:]")
    (( $? == 0 )) && mod_url="http://www.nexusmods.com/fallout4/mods/$n/"
  fi
fi
[ -n "$mod_url" ] && [ ! -e "${bn}.info" ] && wget -O- "$mod_url" | html2text > "${bn}.info"

if [ -e "${bn}.info" ]; then
  adult_mod_stub="This mod contains adult content. You can turn adult content on in your"

  if [ -n "$(grep "$adult_mod_stub" "${bn}.info")" ]; then

    yad --title="What the hack download.." --width=640 --height=480 \
        --text="<span foreground='white' font='18'>Adult mod, open url below in
                browser, save as html in /tmp Make sure to save as html!</span>" \
        --form --field="$mod_url:LINK" "$mod_url"

    if (( $? == 0 )); then
      html="$(ls -1rt /tmp/*.html | tail -n 1)"
      cat "$html" | html2text > "${bn}.info"
      # rm "$html"
    fi
  fi
  if [ -z "$(grep "$adult_mod_stub" "${bn}.info")" ]; then
    if [ -z "$commit_message" ]; then
      commit_message="$(sed -n -r '/^# Please log in or register/b
        s/^# /Name: /p;
        /^### Created by/{n;n;s/^/Author: /p};
        /^  \* Version/{n;n;s~(.*)$~Version/@MachineVersion: \1\nVersion: \1~p}' "${bn}.info")
Website: $mod_url"
      if [ -z "$(echo "$commit_message" | grep "Author: ")" ]; then
        rm "${bn}.info"
        commit_message=
      fi
    fi

    mod_reqs="$(sed -n -r '/^###([^ ]+ )+requirements/{N;:a;N;/\n$/!ba;s/[ \t]+(\n|$)//g;p}' "${bn}.info")"

    while read url name; do
      if [ "${url:0:27}" = "https://www.nexusmods.com/" ]; then
        commit="$(git log -E --grep "^   (Website: $url|Name: $name)$")"
        [ -z "$commit" ] && [ -n "$(echo "$name" | egrep "$ignore_nexus_reqs")" ] &&
          die "Nexus requirement $name is not yet installed (use --ignore-nexus-reqs=RE to ignore this)"
      else
        apropos $name
        (( $? != 0 )) && [ -n "$(echo "$name" | egrep "$ignore_off_site_reqs")" ] &&
          die "Off-site requirement $name may not yet be installed (use --ignore-off-site-reqs=RE to ignore this)"
      fi
    done < <(echo "$mod_reqs" | sed -n -r 's~^\[(.*)\]\((https?://.*)\) \|  $~\2 \1~p')
  fi
fi

if [ -f "$fomod_config" ]; then
  TAG_NAME=
  ATTRIBUTES=
  read_dom () {
      local IFS=\>
      read -r -d \< ENTITY CONTENT
      local ret=$?
      if [ "${ENTITY:0:8}" = '![CDATA[' ]; then
        TAG_NAME="?cdata"
        ATTRIBUTES="${ENTITY:8:$((${#ENTITY}-10))}"
      elif [ -n "${ENTITY#* *}" ]; then
        TAG_NAME="${ENTITY%% *}"
        ATTRIBUTES="${ENTITY#* }"
      else
        TAG_NAME=
        ATTRIBUTES=
      fi
      return $ret
  }
  vercomp () {
    [[ $1 == $2 ]] && return 0
    local IFS=.
    local i ver1=($1) ver2=($2)
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        # fill empty fields in ver2 with zeros
        [[ -z ${ver2[i]} ]] && ver2[i]=0
        ((10#${ver1[i]} > 10#${ver2[i]})) && return 1
        ((10#${ver1[i]} < 10#${ver2[i]})) && return 2
    done
    return 0
  }
  attr() {
    echo -E "${ATTRIBUTES}" | sed -r "s~^.*$1=\"([^\"]*)\".*$~\1~;t;s/^.*$/$2/"
  }
  path() {
    path="$(attr "$1" | sed 'y~\\~/~')"
    if [ "$1" = "source" ]; then
      path="$(echo "$ar_files" | grep -i "^$path$")"
      [ ! -e "$path" ] && die "$path not found (nor its case mismatches)"
      echo "$path"
    elif [ -n "$2" ]; then
      find "$mod_root/$2" -iwholename "$path"
    else
      find ./ -iwholename "./$path" || echo "$path"
    fi
  }
  yad_get_plug() {
    local plug=${RANDOM}
    while [ -n "$(lsipc -m | grep "[-]-key=$plug")" ]; do
      plug=${RANDOM}
    done
    echo "$plug"
  }
  yad_notebook() {
    local tabs=()
    local plug=$(yad_get_plug | tee /dev/stderr)
    local dims=
    case $1 in
      images)
        for i in `seq 0 $2`; do
          local img="${previewImage[$i]}"
          [ -z "$img" ] && continue;
          yad --plug=$plug --tabnum=$((i+1)) --image="$img" &>/dev/null&
          tabs[${#tabs[@]}]="--tab=${pluginName[$i]}"
        done;;
      info) dims='--width=1024 --height=768'
        for i in `seq 0 $2`; do
          local desc="${description[$i]}"
          [ -z "$desc" ] && continue;
          echo "$desc" | yad --plug=$plug --tabnum=$((i+1)) --text-info --wrap &>/dev/null&
          tabs[${#tabs[@]}]="--tab=${pluginName[$i]}"
        done;;
    esac
    [ ${#tabs[@]} -ne 0 ] && yad $dims --notebook --key=$plug "${tabs[@]}" || warn "No $1"
  }
  flags=
  nesting=
  yad_rows=0
  yad_general_args=(--button=yad-ok)
  while read_dom; do
    if [ "${TAG_NAME:0:1}" = '/' ]; then
      nesting="${nesting%${TAG_NAME}}"
    elif [ "${ATTRIBUTES:$((${#ATTRIBUTES}-1)):1}" != "/" ] && [ "${TAG_NAME:0:1}" != '?' ]; then
      nesting="${nesting}/${TAG_NAME}"
    fi
    [ -z "${nesting%*/config*}" ] && continue
    case "$TAG_NAME" in
        moduleName) yad_general_args[${#yad_general_args[@]}]="--title=$CONTENT";;
        moduleImage) yad_general_args[${#yad_general_args[@]}]="--image=$(path "path")";;
        moduleDependencies)
            operator=$(attr "operator" "And");
            case operator in
              Or) condition=0;;
              And) condition=1;;
            esac;;
        gameDependency) target_version ="$(attr "version")"
            vercomp $game_version  $target_version
            (( $? == 2 )) && [[ $operator == And ]] &&
                die "Game version is $game_version but $target_version is required.";;
        fileDependency) f="$(path "file" "f4/$dest_base")"
            state="$(attr "state")"
            [ "$state" = "Active" ] && warn "fileDependency: '$(path "file")' resolved to '$f'" 
            case "$operator:$condition:$state:$f" in
                Or:0:Inactive:|And:1:Inactive:);;
                Or:0:Active:|Or:0:Inactive:*) condition=1;;
                And:1:Active:|And:1:Inactive:*) condition=0;;
            esac;;
        flagDependency)
          echo "$flags" | egrep -q "'$(attr "flag"):$(attr "value")'"
          res=$?
          if [ -z "$flagDependency" ]; then
            flagDependency=$res
          else
            warn "file before flagDependency check (untested branch)"
            if (( $res == 0 )); then
              while read src_dest; do
                sources[${#sources[@]}]="${src_dest%|*}"
                dests[${#dests[@]}]="${src_dest#*|}"
              done < <(echo "$flagDependency" | tr "#" "\n")
            fi
          fi;;
        /moduleDependencies)
            case operator in
              Or)  (( $condition != 1 )) && die 'module "Or" requirements not met!';;
              And) (( $condition != 1 )) && die 'module "And" requirements not met!';;
            esac;;
        installSteps) plug=$RANDOM;
            installStepName=()
            installStepOrder="$(attr "order" "Ascending")";;
        /installSteps)
            # TODO:
            #yad --plug=$plug --tabnum=1 --text="first tab with text" &> res1 &
            #yad --plug=$plug --tabnum=2 --text="second tab" --entry &> res2 &
            #case installStepOrder in
            #    Ascending) tabs=$(echo "${tabs[@]}" | tr " " "\n" | nl | sort -k 2 |
            #        cut -f 1 | sed -r 's/^ +([0-9]+)$/--tab="tab \1"/');;
            #    Descending) tabs=$(echo "${tabs[@]}" | tr " " "\n" | nl | sort -r -k 2 |
            #        cut -f 1 | sed -r 's/^ +([0-9]+)$/--tab="tab \1"/');;
            #esac
            #yad --notebook --key=$plug "${tabs[@]}"
            ;;
        installStep) installStepName[${#installStepName[@]}]="$(attr "name")";;
        /installStep);;

        optionalFileGroups) groupName=()
            optionalFileGroupOrder="$(attr "order" "Ascending")";;
        plugins)
            pluginName=()
            pluginOrder="$(attr "order" "Ascending")";;
        description) description[$yad_rows]="$(echo "$CONTENT" |
            sed -r '1{:a;s/^\n?[ \t]+//;/^$/{N;ba}};/&#xD;/{N;s/&#xD;\n//;s/&#xD;//}')";;
        \?cdata) description[$yad_rows]="${description[$yad_rows]}$ATTRIBUTES";;
        image) preview=--button=Preview:66
          previewImage[$yad_rows]="$(path "path")";;
        folder|file)
          src="$(path "source")"
          # with slash directory contents are rsynced, not directory itself.
          [ "$TAG_NAME" = "folder" ] && src="$src/"
          #//!--/config/conditionalFileInstalls/patterns/pattern/files

          dest="$(path "destination")"
          if [ -z "${nesting%%*/requiredInstallFiles}" ]; then
            sources[${#sources[@]}]="$src"
            dests[${#dests[@]}]="$dest"
          elif [ -n "$(echo "$nesting" | grep "/conditionalFileInstalls/")" ]; then
            if [ "$flagDependency" = "0" ]; then # this is a grep -q result; 0 means succes.
              sources[${#sources[@]}]="$src"
              dests[${#dests[@]}]="$dest"
            elif [ "$flagDependency" != "1" ]; then
              [ -n "${flagDependency}" ] && flagDependency="${flagDependency}#"
              flagDependency="${flagDependency}$src|$dest"
            fi
          else
            [ -n "${plugin_srcs[$yad_rows]}" ] && plugin_srcs[$yad_rows]="${plugin_srcs[$yad_rows]}#"
            plugin_srcs[$yad_rows]="${plugin_srcs[$yad_rows]}$src"
            [ -n "${plugin_dests[$yad_rows]}" ] && plugin_dests[$yad_rows]="${plugin_dests[$yad_rows]}#"
            plugin_dests[$yad_rows]="${plugin_dests[$yad_rows]}$dest"
          fi
          ;;
        flag)
          if [ -z "${nesting%%*/conditionFlags/flag}" ]; then
            (( $yad_rows == 0 )) && yad_cols="$yad_cols cond:HD"
            yad_args="$yad_args$(attr "name"):$CONTENT	"
          fi;;
        #type) type="$(attr "name")";;
        group)
          yad_args=
          preview=
          type=$(attr "type")
          description=()
          previewImage=()
          yad_before=("--text-align=center" '--text=<span foreground="white" font="32">'"$(attr "name")</span>")
          case $type in
              SelectExactlyOne) yad_cols=" sel:RD"; yad_before[2]=--radiolist;;
              SelectAtMostOne)  yad_cols=" sel:CHK"; yad_before[2]=--checklist;
                  yad_before[3]="--limit=1";;
              SelectAny)        yad_cols=" sel:CHK";  yad_before[2]=--checklist;;
            *) echo "FIXME: not yet supported fomod group type: '$type'" 1>&2;;
          esac;;
        /group)
          ncols=$(echo "$yad_cols" | tr -c -d " " | wc -c)
          nargs=$(echo "$yad_args" | tr -c -d "\t" | wc -c)
          (( $(($nargs % $ncols)) != 0 )) && die "${yad_args//	/ }\n\n\n$yad_cols"
          while [ 1 ]; do
            opt_sources=()
            selection="$(yad "${yad_general_args[@]}" $preview --button=info:42 --always-print-result \
                --list "${yad_before[@]}" ${yad_cols// / --column=} $yad_args)"
            yad_res=$?
            i=0
            for col in ${yad_cols}; do
              i=$((i+1))
              value="$(echo "$selection" | cut -d "|" -f $i)"
              case $col in
                cond:HD)   conds="$value";;
                name:TEXT) names="$value";;
                nr:HD)       nrs="$value";;
              esac
            done
            case $yad_res in
             66|42)
                 if (( $yad_res == 66 )); then
                   yad_notebook images ${#pluginName[@]} #"${previewImage[@]}"
                 else
                   yad_notebook info ${#pluginName[@]} #"${description[@]}"
                 fi
                 if (( $ncols == $nargs )); then
                   yad_args="TRUE	${yad_args#*	}"
                 else
                   warn "$yad_args"
                   subs="s/(TRUE|FALSE)((\t[^\t]+){$((ncols-1))})/FALSE\2/g"

                   for i in ${nrs[@]}; do
                     subs="$subs;s/^((([^\t]+\t){$ncols}){$i})FALSE/\1TRUE/"
                   done
                   warn "${subs//;/\\n}"
                   yad_args="$(echo "$yad_args" | sed -r "$subs")"
                   warn "$yad_args"
                 fi;;
              0) break;;
              *) die "You chose quit.";;
            esac
          done
          while read fl; do
            flags="$flags '$fl'"
          done < <(echo "$conds")

          for i in ${nrs[@]}; do
            n=$((i*ncols))
            while read s; do
              sources[${#sources[@]}]="$s"
            done  < <(echo "${plugin_srcs[$n]}" | tr "#" "\n") 
            while read d; do
              dests[${#dests[@]}]="$d"
            done  < <(echo "${plugin_dests[$n]}" | tr "#" "\n")
          done
          yad_rows=0;;
      plugin)  (( $yad_rows == 0 )) && yad_cols="$yad_cols name:TEXT"
                 plugin_srcs=
                 plugin_dests=
                 pluginName[${#pluginName[@]}]="$(attr "name")"
                 yad_args="${yad_args}FALSE	$(attr "name")	";;
      /plugin) if (( $yad_rows == 0 )); then
                   yad_cols="$yad_cols nr:HD"
                 fi
                 yad_args="$yad_args$yad_opt_args$yad_rows	"
                 yad_rows=$((yad_rows+1));;
        pattern) flagDependency=;;
    esac
  done < <(xmllint "$fomod_config")
fi

if (( ${#sources[@]} == 0 )); then
  while read d; do
    [ "$d" = "$bn/$bn.info" ] && continue;
    for r in "${readme[@]}"; do
      [ "$r" = "$d" ] && continue 2
    done
    [ -n "$fomod_dir" ] && [[ "$d" =~ ^$fomod_dir ]] && continue
    [ -e "$d" ] && sources[${#sources[@]}]="$d" || die "$d does not exist from here?"
    dests[${#dests[@]}]=""
  done < <(echo "$ar_dirs")
fi
#yad --width=1024 --height=768 --list --no-click \
#  '--text=<span foreground="white" font="24">folders to be transferred:</span>' \
#    --no-selection --column=Name "${sources[@]}"
#(( $? != 0 )) && die "You chose quit"
cd "$mod_root/f4"
exclude_git=
[ -z "$dest_base" ] && exclude_git='--exclude="f4/.git*"'

(( ${#sources[@]} != ${#dests[@]} )) && die "inconsistent number of sources and destinations for transfer"

transfer_selection= 
for i in `seq 0 $((${#sources[@]}-1))`; do
  src="${sources[$i]}"
  tgt="$dest_base${dests[$i]}"

  [ -z "$src" ] && continue
  [ -n "$(echo "${transfer_selection}" | grep "$src")" ] && continue
  transfer_selection="${transfer_selection:-Selected for transfer:}
$src"

  rsync --safe-links --prune-empty-dirs -rlptgo $exclude_git "$@" "$OLDPWD/$src" "$tgt" ||
    warn "failed:rsync --safe-links --prune-empty-dirs -rlptgo $exclude_git '$@' '$OLDPWD/$src' '$tgt'" 2

  until resolve_tracked_case_insensitivity_for_type d; do :; done
  resolve_tracked_case_insensitivity_for_type f

  (( $stage == 1 )) && git ls-files -o -m --exclude-standard | xargs -r -d "\n" git stage --
done
# if it's just everything, no need to list explicitly in commit message
#[ -z "$fomod_dir" ] && transfer_selection=
(( $stage == 1 )) && git commit -q -m "${commit_message}
Archive: $(basename "$ar")
$append_message
$mod_reqs
$transfer_selection";
(( $keep_mod == 0 )) && rm -rf "$stash"
cd "$mod_root"
